package tjc.model.agent;

import tjc.model.World;
import tjc.model.data.DataManager;
import tjc.model.power.Power;

import java.util.ArrayList;
import java.util.Collections;

/**
 * The agent class stores the information about a given agent and contains functions to manage the power plants
 * held within it.
 */
public class Agent {

    private final int id;                   // A unique identifier for each agent, used primarily for debugging
    private final ArrayList<Power> power;   // All of the power plants currently held by the agent
    private int tick;                       // The most recent tick that the agent has operated on
    private int credits;                    // The carbon credits held by the agent
    private float required;                 // The amount of electricity the agent should produce per tick
    private final AgentStats stats;         // The total and per tick electricity and carbon production of the agent as well as the revenue
//    private float generatedThisTick;

    /**
     * Constructor sets the unique identifier and the current tick, initialises the AgentStats and the power
     * plant list
     * @param id    The unique identifier for the agent
     * @param tick  The tick in which the agent was created
     */
    public Agent(int id, int tick) {
        this.id = id;
        this.stats = new AgentStats();
        this.tick = tick;
        this.power = new ArrayList<>();
    }

    /**
     * Adds a power plant to the holdings of the agent
     * @param power The power plant to add
     */
    public void addPower(Power power) {
        this.power.add(power);
    }

    /**
     * Updates the agent for a tick when running on a tax system. Shows a warning if the agent has already
     * been updated for the current tick, sorts the held power plants based on revenue for the current tax
     * rate and puts them in descending order. Iterates through the power plants, generating electricity
     * until the required amount is reached. Removes power plants who have been inactive for too long.
     * @param tick          The current tick to update for
     * @param dataManager   The dataManager that stores the information for the model
     */
    public void updateDataTax(int tick, DataManager dataManager) {
        if (this.tick == tick) System.out.println(":: WARNING: Agent " + id + " called twice in tick " + tick);
        this.tick = tick;
        power.sort(((o1, o2) -> Float.compare(o1.normalisedIncomeFromTax(), o2.normalisedIncomeFromTax())));
        Collections.reverse(power);
        float totalElecticity = 0;
        ArrayList<Power> toRemove = new ArrayList<>();
        for(Power p: power) {
            if (totalElecticity > required) {
                if (!p.decayIdle()) toRemove.add(p);
            }
            else totalElecticity += usePower(p, dataManager, true);
        }
        for (Power p: toRemove) deletePower(p);
    }

    /**
     * Use a power plant, storing the amounts of electricity, money and carbon dioxide being generated
     * @param p     The power plant to use
     * @param dm    The data manager to store the information in
     * @return      The amount of electricity generated by the plant
     */
    private float usePower(Power p, DataManager dm, boolean isTax) {
        stats.updateElectricity(p.getProduction(), tick);
        if (isTax) stats.updateMoney(p.calculateIncomeFromTax());
        else stats.updateMoney(p.calculateIncomeFromTrade());
        stats.updateCarbon(p.getCarbon());
        dm.add(p);
        p.resetIdle();
        p.setUsedThisTick(true);
        return p.getProduction();
    }

    /**
     * Removes a power plant
     * @param p The power plant to remove
     */
    private void deletePower(Power p) {
        power.remove(p);
    }

    /**
     * Getter for the held power plants
     * @return  The held power plants
     */
    public ArrayList<Power> getPower() {
        return power;
    }

    /**
     * Getter for the total held money
     * @return  The total money
     */
    public double getMoneyTot() {
        return stats.getMoneyTot();
    }

    /**
     * Adds credits to the currently held credits
     * @param credits   The amount of credits to add
     */
    public void addCredits(int credits) {
        this.credits += credits;
    }

    /**
     * Reset the number of credits held to zero
     */
    public void zeroCredits() {
        this.credits = 0;
    }

    /**
     * Gets the mean income per tonne of carbon dioxide from the most efficient power plants
     * @return The mean income per tonne of CO2
     */
    public float getMeanRequiredCapIncome() {
        float total = 0;
        float tonnesCO2 = 0;
        int idx = 0;
        while (total < required && idx < power.size()) {
            tonnesCO2 += power.get(idx).getCarbon();
            total += power.get(idx++).getProduction() * World.getEnergyPrice();
        }
        return total / tonnesCO2;
    }

    /**
     * Sets the initial money held by the agent
     * @param initialMoney  The starting money for the agent
     */
    public void setStartMoney(float initialMoney) {
        stats.setMoneyTot(initialMoney);
    }

    /**
     * Sets the required power that the agent should produce per tick
     * @param required  The amount of power to be produced
     */
    public void setRequired(float required) {
        this.required = required;
    }

    /**
     * Getter for the unique identifier
     * @return  The id of the agent
     */
    public int getId() {
        return id;
    }

    /**
     * Calculates and returns the total amount of power the agent could produce if using all
     * held power plants
     * @return  The total amount of power
     */
    public float getTotalPotential() {
        float total = 0;
        for (Power p: power) total += p.getProduction();
        return total;
    }

    /**
     * Getter for the current number of Carbon Credits held by the agent
     * @return The number of carbon credits held
     */
    public int getCredits() {
        return credits;
    }

    /**
     * Decide on whether to put in a bid for a given value. The maximum value to offer is calculated
     * based off the income per carbon unit for the current most efficient unused power plant. This is
     * also weighted by the portion of credits left unused relative to the portion of the agents goal
     * power generation.
     * @param value             The value to accept or reject
     * @param portionComplete   The portion of credits remaining
     * @return                  The number of credits to buy at the given value
     */
    public int decideBid(float value, float portionComplete) {
        double reqCarbon = -1;
        float maxPrice = -1;
        for (Power p: power) {
            if (!p.isUsedThisTick()) {
                reqCarbon = p.getCarbon();
                maxPrice = p.carbonNormalisedIncome() * 0.9f;
                break;
            }
        }
        if (reqCarbon == -1 || maxPrice == -1) return -1;
        reqCarbon = Math.ceil(reqCarbon);
        float weight  = 1 - portionComplete + getPortionOfRequired();
        if (weight < 0.1) weight = 0.1f;
        maxPrice = weight > 1 ? maxPrice : maxPrice / weight;
        return value <= maxPrice && getMoneyTot() > maxPrice * reqCarbon ? (int) reqCarbon : -1;
    }

    /**
     * Adds money to the agents reserves
     * @param amount    The amount of money to add
     */
    public void addMoney(float amount) {
        stats.updateMoney(amount);
    }

    /**
     * Use credits to run a power plant. Show an error if the number of credits being used is out
     * by more than 1 from the required credits to run the current best power plant
     * @param number    The number of credits
     * @param dm        The data manager to pass through to usePower
     */
    public void useCredits(int number, DataManager dm) {
        for (Power p: power) if (!p.isUsedThisTick()) {
            if (number > p.getCarbon() - 1 && number < p.getCarbon() + 1) {
                usePower(p, dm, false);
                break;
            }
            else System.out.println(":: ERROR: Bought incorrect number of credits" + p.toString());
        }
    }

    /**
     * Gets the current portion fo the required electricity generation that has been achieved in the
     * current tick
     * @return  The portion of electricity generated
     */
    private float getPortionOfRequired() {
        return stats.getElectricityTick() / required;
    }

    /**
     * Sets all held power plants as unused.
     */
    public void setUnused() {
        power.forEach(Power::resetUsedThisTick);
    }

    public void sortPowerNormalised() {
        power.sort(((o1, o2) -> Float.compare(o1.carbonNormalisedIncome(), o2.carbonNormalisedIncome())));
        Collections.reverse(power);
    }


    public void showCurrentMoney() {
        System.out.println(stats.getMoneyTot());
    }

    public void costUnused() {
        float costs = 0;
        for (Power p: power) costs += p.getUnusedCost();
        addMoney(-1 * costs);
    }
//
//    public void cleanUpPower() {
//        ArrayList<Power> toRemove = new ArrayList<>();
//        for (Power p: power) if (!p.decayIdle()) toRemove.add(p);
//        for (Power p: toRemove) deletePower(p);
//    }
}
