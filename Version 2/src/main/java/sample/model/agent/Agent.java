package sample.model.agent;

import sample.model.data.DataManager;
import sample.model.power.Power;

import java.util.ArrayList;
import java.util.Collections;


public class Agent {

    private final int id;                   // A unique identifier for each agent, used primarily for debugging
    private final ArrayList<Power> power;   // All of the power plants currently held by the agent
    private int tick;                       // The most recent tick that the agent has operated on
    private int credits;                    // The carbon credits held by the agent
    private float required;                 // The amount of electricity the agent should produce per tick
    private final AgentStats stats;         // The total and per tick electricity and carbon production of the agent as well as the revenue

    /**
     * Constructor sets the unique identifier and the current tick, initialises the AgentStats and the power
     * plant list
     * @param id    The unique identifier for the agent
     * @param tick  The tick in which the agent was created
     */
    public Agent(int id, int tick) {
        this.id = id;
        this.stats = new AgentStats();
        this.tick = tick;
        this.power = new ArrayList<>();
    }

    /**
     * Adds a power plant to the holdings of the agent
     * @param power The power plant to add
     */
    public void addPower(Power power) {
        this.power.add(power);
    }

    /**
     * Updates the agent for a tick when running on a tax system. Shows a warning if the agent has already
     * been updated for the current tick, sorts the held power plants based on revenue for the current tax
     * rate and puts them in descending order. Iterates through the power plants, generating electricity
     * until the required amount is reached. Removes power plants who have been inactive for too long.
     * @param tick          The current tick to update for
     * @param dataManager   The dataManager that stores the information for the model
     */
    public void updateDataTax(int tick, DataManager dataManager) {
        if (this.tick == tick) System.out.println(":: WARNING: Agent " + id + " called twice in tick " + tick);
        this.tick = tick;
        power.sort(((o1, o2) -> Float.compare(o1.normalisedIncomeFromTax(), o2.normalisedIncomeFromTax())));
        Collections.reverse(power);
        float totalElecticity = 0;
        ArrayList<Power> toRemove = new ArrayList<>();

        for(Power p: power) {
            if (totalElecticity > required) {
                if (!p.decayIdle()) toRemove.add(p);
            }
            else totalElecticity += usePower(p, dataManager);
        }
        for (Power p: toRemove) deletePower(p);
    }

    /**
     * TODO
     * @param tick
     * @param dataManager
     */
    public void updateDataTrade(int tick, DataManager dataManager) {
        if (this.tick == tick) System.out.println(":: WARNING: Agent " + id + " called twice in tick " + tick);
        this.tick = tick;
        power.sort(((o1, o2) -> Float.compare(o1.carbonNormalisedIncome(), o2.carbonNormalisedIncome())));
        Collections.reverse(power);
        float totalElectricity = 0;
        ArrayList<Power> toRemove = new ArrayList<>();

        for (Power p: power) if (totalElectricity > required) if (!p.decayIdle()) toRemove.add(p);
        for (Power p: toRemove) deletePower(p);
    }

    /**
     * Use a power plant, storing the amounts of electricity, money and carbon dioxide being generated
     * @param p     The power plant to use
     * @param dm    The data manager to store the information in
     * @return      The amount of electricity generated by the plant
     */
    private float usePower(Power p, DataManager dm) {
        stats.updateElectricity(p.getProduction(), tick);
        stats.updateMoney(p.calculateIncomeFromTax());
        stats.updateCarbon(p.getCarbon());
        dm.add(p);
        return p.getProduction();
    }

    /**
     * Removes a power plant
     * @param p The power plant to remove
     */
    private void deletePower(Power p) {
        power.remove(p);
    }

    /**
     * Getter for the held power plants
     * @return  The held power plants
     */
    public ArrayList<Power> getPower() {
        return power;
    }

    /**
     * Getter for the total held money
     * @return  The total money
     */
    public double getMoneyTot() {
        return stats.getMoneyTot();
    }

    /**
     * Adds credits to the currently held credits
     * @param credits   The amount of credits to add
     */
    public void addCredits(int credits) {
        this.credits += credits;
    }

    /**
     * Reset the number of credits held to zero
     */
    public void zeroCredits() {
        this.credits = 0;
    }

    /**
     * Gets the mean value of all power stations normalised per tonne of carbon
     * @return  The mean value
     */
    public float getMeanCarbonValue() {
        float total = 0;
        for (Power p: power) total += p.carbonNormalisedIncome();
        return total / power.size();
    }

    /**
     * Sets the initial money held by the agent
     * @param initialMoney  The starting money for the agent
     */
    public void setStartMoney(float initialMoney) {
        stats.setMoneyTot(initialMoney);
    }

    /**
     * Sets the required power that the agent should produce per tick
     * @param required  The amount of power to be produced
     */
    public void setRequired(float required) {
        this.required = required;
    }

    /**
     * Getter for the unique identifier
     * @return  The id of the agent
     */
    public int getId() {
        return id;
    }

    /**
     * Calculates and returns the total amount of power the agent could produce if using all
     * held power plants
     * @return  The total amount of power
     */
    public float getTotalPotential() {
        float total = 0;
        for (Power p: power) total += p.getProduction();
        return total;
    }

}
